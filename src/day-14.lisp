(defpackage :day-14
  (:use :cl)
  (:import-from :utils :read-day-file)
  (:import-from :cl-ppcre :do-register-groups)
  (:import-from :alexandria :hash-table-alist)
  (:export #:part-1 #:part-2))

(in-package :day-14)

(defun load-data ()
  (let* ((initial (read-day-file "14"))
         (template (car initial))
         (hash (make-hash-table :test #'equal)))
    (loop for instruction in (cddr initial)
          do (do-register-groups (pattern inserts) ("^([A-Z]{2}) -> ([A-Z])$" instruction)
               (setf (gethash pattern hash) inserts)))
    (values template hash)))

(defun polymer-step (template table)
  (loop with ret = (make-array (1- (* 2 (length template))) :element-type 'character)
        with next-write-index = -1
        for i from 0 below (1- (length template))
        do (let* ((lookup (subseq template i (+ 2 i)))
                  (insert (gethash lookup table)))
             (setf (aref ret (incf next-write-index)) (aref lookup 0))
             (setf (aref ret (incf next-write-index)) (aref insert 0))
             (setf (aref ret (incf next-write-index)) (aref lookup 1))
             (decf next-write-index))
        finally (return ret)))

(defun do-counts (template)
  (let* ((uniq (remove-duplicates template :test #'char=))
         (counts (map 'list #'(lambda (c)
                                (cons c (count c template :test #'char=))) uniq)))
    (sort counts #'(lambda (first second)
                     (< (cdr first) (cdr second))))))

(defun polymer-step-stateful-map (state table)
  (let ((augment-table (make-hash-table :test #'equal)))
    (loop for k being the hash-keys in state using (hash-value v)
          do (let* ((insert (gethash k table))
                    (augment-key-1 (make-array 2 :element-type 'character))
                    (augment-key-2 (make-array 2 :element-type 'character)))
               (setf (aref augment-key-1 0) (aref k 0))
               (setf (aref augment-key-1 1) (aref insert 0))
               (setf (aref augment-key-2 0) (aref insert 0))
               (setf (aref augment-key-2 1) (aref k 1))
               (incf (gethash augment-key-1 augment-table 0) v)
               (incf (gethash augment-key-2 augment-table 0) v)))
    augment-table))

(defun part-1 ()
  (multiple-value-bind (template table) (load-data)
    (let ((result template))
      (dotimes (n 10)
        (setf result (polymer-step result table)))
      (let ((sorted-counts (do-counts result)))
        (- (cdar (last sorted-counts))
           (cdr (first sorted-counts)))))))

(defun part-2 ()
  (multiple-value-bind (template table) (load-data)
            do (incf (gethash (subseq template i (+ 2 i)) state 0)))
      (dotimes (n 40)
        (setf state (polymer-step-stateful-map state table)))
      (loop with letter-counts = (make-hash-table :test #'equal)
            for k being the hash-keys in state using (hash-value v)
            do (progn
                 (incf (gethash (aref k 0) letter-counts 0) v)
                 (incf (gethash (aref k 1) letter-counts 0) v))
            finally (let ((sorted-counts (sort (hash-table-alist letter-counts)
                                               #'(lambda (first second)
                                                   (< (cdr first) (cdr second))))))
                      (return sorted-counts))))))
                      ;(return (- (cdar (last sorted-counts))
                       ;          (cdr (first sorted-counts)))))))))

