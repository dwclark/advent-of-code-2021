(defpackage :day-14
  (:use :cl)
  (:import-from :utils :read-day-file)
  (:import-from :cl-ppcre :do-register-groups)
  (:import-from :alexandria :hash-table-alist :ensure-gethash)
  (:export #:part-1 #:part-2))

(in-package :day-14)

(defun load-data ()
  (let* ((initial (read-day-file "14"))
         (template (car initial))
         (hash (make-hash-table :test #'equal)))
    (loop for instruction in (cddr initial)
          do (do-register-groups (pattern inserts) ("^([A-Z]{2}) -> ([A-Z])$" instruction)
               (setf (gethash pattern hash) inserts)))
    (values template hash)))

(defun load-data-2 ()
  (let* ((initial (read-day-file "14"))
         (template (car initial))
         (hash (make-hash-table :test #'equal)))
    (loop for instruction in (cddr initial)
          do (do-register-groups (pattern inserts) ("^([A-Z]{2}) -> ([A-Z])$" instruction)
               (setf (gethash (cons (aref pattern 0) (aref pattern 1)) hash) (aref inserts 0))))
    (values template hash)))

(defun polymer-step (template table)
  (loop with ret = (make-array (1- (* 2 (length template))) :element-type 'character)
        with next-write-index = -1
        for i from 0 below (1- (length template))
        do (let* ((lookup (subseq template i (+ 2 i)))
                  (insert (gethash lookup table)))
             (setf (aref ret (incf next-write-index)) (aref lookup 0))
             (setf (aref ret (incf next-write-index)) (aref insert 0))
             (setf (aref ret (incf next-write-index)) (aref lookup 1))
             (decf next-write-index))
        finally (return ret)))

(defun do-counts (template)
  (let* ((uniq (remove-duplicates template :test #'char=))
         (counts (map 'list #'(lambda (c)
                                (cons c (count c template :test #'char=))) uniq)))
    (sort counts #'(lambda (first second)
                     (< (cdr first) (cdr second))))))

(defun template->augment (template)
  (loop with hash = (make-hash-table :test #'equal)
        for i from 0 below (1- (length template))
        do (ensure-gethash (list (cons (aref template i) (aref template (1+ i)))
                                 (if (= (length template) (+ 2 i)) 'last 'regular)) hash 1)
        finally (return hash)))

(defun polymer-step-2 (augment table)
  (loop with new-augment = (make-hash-table :test #'equal)
        for (cell type) being the hash-keys in augment using (hash-value c)
        do (let ((transform (gethash cell table))
                 (last-type (if (eq 'regular type) 'regular 'last)))
             (incf (gethash (list (cons (car cell) transform) 'regular) new-augment 0) c)
             (incf (gethash (list (cons transform (cdr cell)) last-type) new-augment 0) c))
        finally (return new-augment)))

(defun diff-counts (augment)
  (loop with totals = (make-hash-table :test #'equal)
        for ((f . s) type) being the hash-keys in augment using (hash-value c)
        do (progn
             (incf (gethash f totals 0) c)
             (if (eq type 'last)
                 (incf (gethash s totals 0) c)))
        finally (let* ((alist (hash-table-alist totals))
                       (sorted (sort alist #'(lambda (c1 c2)
                                               (< (cdr c1) (cdr c2))))))
                  (return (- (cdar (last sorted))
                             (cdr (first sorted)))))))

(defun part-1 ()
  (multiple-value-bind (template table) (load-data)
    (let ((result template))
      (dotimes (n 10)
        (setf result (polymer-step result table)))
      (let ((sorted-counts (do-counts result)))
        (- (cdar (last sorted-counts))
           (cdr (first sorted-counts)))))))

(defun part-2 ()
  (multiple-value-bind (template table) (load-data-2)
    (let ((augment (template->augment template)))
      (dotimes (n 40)
        (setf augment (polymer-step-2 augment table)))
      (diff-counts augment))))
