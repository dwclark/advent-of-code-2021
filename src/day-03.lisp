(defpackage :day-03
  (:use :cl)
  (:import-from :utils :read-day-file)
  (:export #:part-1 #:part-2))

(in-package :day-03)

(defun one-bit-counts (width nums)
  (loop with counts = (make-array width :initial-element 0)
        for idx from 0 below width
        do (setf (aref counts idx) (count-if #'(lambda (n) (logbitp idx n)) nums))
        finally (return counts)))

(defun parse (raw)
  (mapcar #'(lambda (s) (read-from-string (concatenate 'string "#b" s))) raw))

(defun gamma-epsilon (nums width counts idx gamma epsilon)
  (if (= idx width)
      (* gamma epsilon)
      (if (< (/ (length nums) 2) (aref counts idx))
          (gamma-epsilon nums width counts (1+ idx)
                         (logior gamma (ash 1 idx)) epsilon)
          (gamma-epsilon nums width counts (1+ idx)
                         gamma (logior epsilon (ash 1 idx))))))
(defun part-1 ()
  (let* ((raw (read-day-file "03"))
         (width (length (car raw)))
         (nums (parse raw)))
    (gamma-epsilon nums width (one-bit-counts width nums) 0 0 0)))

(defun oxygen-co2 (nums width idx first second)
  (if (= 1 (length nums))
      (car nums)
      (let* ((counts (one-bit-counts width nums))
             (to-call (if (<= (/ (length nums) 2) (aref counts idx)) first second)))
        (oxygen-co2 (funcall to-call idx nums) width (1- idx) first second))))

(defun part-2 ()
  (let* ((first #'(lambda (idx nums) (remove-if-not #'(lambda (x) (logbitp idx x)) nums)))
         (second #'(lambda (idx nums) (remove-if #'(lambda (x) (logbitp idx x)) nums)))
         (raw (read-day-file "03"))
         (width (length (car raw)))
         (nums (parse raw)))
    (* (oxygen-co2 nums width (1- width) first second)
       (oxygen-co2 nums width (1- width) second first))))
